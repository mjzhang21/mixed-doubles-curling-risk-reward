


```{python}
import pandas as pd
import numpy as np

df_competition = pd.read_csv("../data/Competition.csv")
df_competitors  = pd.read_csv("../data/Competitors.csv")
df_games        = pd.read_csv("../data/Games.csv")
df_teams        = pd.read_csv("../data/Teams.csv")
df_ends         = pd.read_csv("../data/Ends.csv")
df_stones       = pd.read_csv("../data/Stones.csv")

```
Merge the ends and games data with the stones data.
```{python}

merged = pd.merge(
    df_stones,
    df_ends,
    on=["CompetitionID","SessionID","GameID","EndID","TeamID"],
    how="left"
)

df = pd.merge(
    merged,
    df_games,
    on=["CompetitionID","SessionID","GameID"],
    how="left"
)
df.columns = df.columns.str.lower().str.replace('id', '_id')

df.head()
```
```{python}
df.info()
```
```{python}
df.isnull().sum()
```
```{python}
categorical_cols = [
    'competition_id',
    'end_id',
    'player_id',
    'task',
    'handle',
    'sheet',
    'lsfe',
    'winner',
    'powerplay',
    'timeout',
    'points'
]


for col in categorical_cols:
    freq_table = df[col].value_counts(dropna=False).reset_index()
    freq_table.columns = [col, 'Frequency']
    freq_table['Percentage'] = (freq_table['Frequency'] / freq_table['Frequency'].sum() * 100).round(2)
    
    print(f"Frequency table for {col}:\n", freq_table, "\n")
```

Fill in data that is supposed to be 0.
```{python}
cols_to_fill = ['powerplay', 'timeout']
df[cols_to_fill] = df[cols_to_fill].fillna(0)
```
Turn -1 into NA or invalid data.
```{python}
columns_to_fix = ['task', 'handle'] 
df[columns_to_fix] = df[columns_to_fix].replace(-1, pd.NA)
df.isnull().sum()
```
Drop rows which dont have any coordinate data.
```{python}
df = df.dropna(subset=["stone_3_x"])
df.isnull().sum()
```
```{python}
count = 0
for (cid, sid, gid, eid), game in df.groupby(['competition_id','session_id','game_id', 'end_id']):
    print(f"Competition {cid}, Session {sid}, Game {gid}, End {eid}")
    print(game[["team_id","lsfe","resultstr1","resultstr2"]])
    print("-" * 50)
    count += 1
    if count >= 10:
        break
```
Create hammer column that alternates according to curling rules.
```{python}
import pandas as pd

df = df.sort_values(["competition_id", "session_id", "game_id", "end_id"])

df["hammer"] = -1 

for (cid, sid, gid), game in df.groupby(["competition_id", "session_id", "game_id"]):
    game = game.sort_values("end_id")
    
    team1 = game["team_id1"].iloc[0]
    team2 = game["team_id2"].iloc[0]

    lsfe = game["lsfe"].iloc[0] 
    hammer_val = lsfe  
    
    # Loop through ends
    for eid, end in game.groupby("end_id"):
        # Assign hammer for this end
        df.loc[end.index, "hammer"] = hammer_val
        
        # Compute points for each team in this end
        points_team1 = end.loc[end["team_id"] == team1, "result"].iloc[0]
        points_team2 = end.loc[end["team_id"] == team2, "result"].iloc[0]
        
        # If hammer team scored, switch hammer for next end
        if (hammer_val == 1 and points_team1 > 0) or (hammer_val == 0 and points_team2 > 0):
            hammer_val = 1 - hammer_val 

```
```{python}
count = 0
for (cid, sid, gid, eid), game in df.groupby(['competition_id','session_id','game_id', 'end_id']):
    print(f"Competition {cid}, Session {sid}, Game {gid}, End {eid}")
    print(game[["team_id","lsfe","result","hammer"]])
    print("-" * 50)
    count += 1
    if count >= 8:
        break
```
Fix invalid/ mistyped result and team id.
```{python}
shots_per_team = df.groupby(["competition_id","session_id","game_id","end_id","team_id"]).size()
print(shots_per_team.describe())
print(shots_per_team[shots_per_team == 6])
cid, sid, gid, eid= 24250026, 18, 1, 9
df_invalid_shots = df[(df["competition_id"] == cid) &
            (df["session_id"] == sid) &
            (df["game_id"] == gid) &
            (df["end_id"] == eid)][["team_id","end_id","result"]]

print(df_invalid_shots)
df.loc[25375, ["team_id", "result"]] = [37, 1]
```
```{python}
import matplotlib.pyplot as plt

mean_points = df.groupby("end_id")["result"].mean()
plt.bar(mean_points.index.astype(str), mean_points.values, color='skyblue')
plt.title("Average points per end")
plt.xlabel("End")
plt.ylabel("Average Points")
plt.show()
```
```{python}
df[df["result"] >5][["game_id","session_id","competition_id","end_id","result"]].head()
```
```{python}
df.loc[df["result"] > 5, "result"] = pd.NA
```
```{python}
mean_points = df.groupby("end_id")["result"].mean()
plt.bar(mean_points.index.astype(str), mean_points.values, color='skyblue')
plt.title("Average points per end")
plt.xlabel("End")
plt.ylabel("Average Points")
plt.show()
```
Average points per end looks more evenly spread now.
```{python}
end_totals = df.drop_duplicates(subset=["competition_id","session_id","game_id","end_id","team_id"]).groupby(["competition_id","session_id","game_id","team_id","team_id1","team_id2",'resultstr1','resultstr2'])["result"].sum()

df2 = end_totals.to_frame("result").reset_index()

df2
```
```{python}
mask = (
    ((df2["team_id"] == df2["team_id1"]) & (df2["resultstr1"] == df2["result"])) |
    ((df2["team_id"] == df2["team_id2"]) & (df2["resultstr2"] == df2["result"]))
)

mismatch_rows = df2[~mask]
mismatch_rows
```
Replace all rows from result column with the results from the calculated result of points
```{python}
df_merged = df.merge(
    df2[["competition_id","session_id","game_id","team_id","result"]],
    on=["competition_id","session_id","game_id","team_id"],
    how="left",
    suffixes=("", "_corrected")
)
df_merged["result"] = df_merged["result_corrected"]
df_merged = df_merged.drop(columns=["result_corrected"])
```

```{python}
null_counts = df_merged.isnull().sum()
print(null_counts)
```
Check if all stone coordinates are valid
```{python}
x_cols = ['stone_1_x',
            'stone_2_x',
            'stone_3_x',
            'stone_4_x',
            'stone_5_x',
            'stone_6_x',
            'stone_7_x',
            'stone_8_x',
            'stone_9_x',
            'stone_10_x',
            'stone_11_x',
            'stone_12_x']
y_cols   = ['stone_1_y',
            'stone_2_y',
            'stone_3_y',
            'stone_4_y',
            'stone_5_y',
            'stone_6_y',
            'stone_7_y',
            'stone_8_y',
            'stone_9_y',
            'stone_10_y',
            'stone_11_y',
            'stone_12_y']  
             
x_min, x_max = 0, 1500
y_min, y_max = 0, 3000

# Create masks column by column
x_ok = (df[x_cols] >= x_min) & (df[x_cols] <= x_max) | (df[x_cols] == 4095)
y_ok = (df[y_cols] >= y_min) & (df[y_cols] <= y_max) | (df[y_cols] == 4095)

# Rows where all x and y columns are okay
rows_ok = x_ok.all(axis=1) & y_ok.all(axis=1)

# Rows that are NOT ok
rows_out_of_range = df[~rows_ok]

print(rows_out_of_range)

```
All the stone coordinates are in range


```{python}
df.info()
```
```{python}
categorical_cols = [
    'competition_id',
    'end_id',
    'player_id',
    'task',
    'handle',
    'sheet',
    'lsfe',
    'winner',
    'powerplay',
    'timeout',
    'points'
]


for col in categorical_cols:
    freq_table = df[col].value_counts(dropna=False).reset_index()
    freq_table.columns = [col, 'Frequency']
    freq_table['Percentage'] = (freq_table['Frequency'] / freq_table['Frequency'].sum() * 100).round(2)
    
    print(f"Frequency table for {col}:\n", freq_table, "\n")
```
We will explore the different types of shots
"0": "Draw"
"1": "Front"
"2": "Guard"
"3": "Raise / Tap-back"
"4": "Wick / Soft Peeling"
"5": "Freeze"
"6": "Take-out"
"7": "Hit and Roll"
"8": "Clearing"
"9": "Double Take-out"
"10": "Promotion Take-out"
"11": "through"
"13": "no statistics"
```{python}
freq_table = df['task'].value_counts().reset_index()
freq_table.columns = ['Task', 'Frequency']
freq_table['Percentage'] = (freq_table['Frequency'] / freq_table['Frequency'].sum() * 100).round(2)
print(freq_table)
bars = plt.bar(freq_table['Task'].astype(str), freq_table['Frequency'], color='skyblue')
plt.title('Frequency of Task Values')
plt.xlabel('Task')
plt.ylabel('Frequency')
```

Draw is the most common shot by far.
Freeze and Through are the least common.

How often players perfectly execute their shot?
```{python}
freq_table = df['points'].value_counts().reset_index()
freq_table.columns = ['Point', 'Frequency']
freq_table['Percentage'] = (freq_table['Frequency'] / freq_table['Frequency'].sum() * 100).round(2)
print(freq_table)
bars = plt.bar(freq_table['Point'].astype(str), freq_table['Frequency'], color='skyblue')
plt.title('Frequency of Point Values')
plt.xlabel('Task')
plt.ylabel('Frequency')
```
How well do players execute different shots?
```{python}
avg_points = df.groupby('task')['points'].mean().reset_index()

# Sort by average points descending
avg_points = avg_points.sort_values(by='points', ascending=False)

# Plot
plt.figure(figsize=(10,6))
plt.bar(avg_points['task'], avg_points['points'], color='skyblue')
plt.xlabel('Task')
plt.ylabel('Average Points')
plt.title('Average Points by Task')
plt.xticks(rotation=45)
plt.show()

```