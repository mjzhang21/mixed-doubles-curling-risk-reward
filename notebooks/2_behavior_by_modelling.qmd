---
title: "CSAS 2026: Behavior Classes"
author: "Alejandro Haerter"
date: "2026-01-13"
format:
  pdf:
    colorlinks: true
    linkcolor: blue
    number-sections: true
    geometry: margin=1in
    fontsize: 11pt 
---

The final plan.

# Build the analysis unit: team-end

```{python}
import pandas as pd
import numpy as np

df = pd.read_csv("../data/stones_master_1.csv")  # you already have this


# Ends is a dataframe which contains two rows per match an end; one for each team.
ends = (
    df[["match_id", "end_id", "team_id1", "team_id2"]]
    .dropna(subset=["match_id", "end_id", "team_id1", "team_id2"])
    .drop_duplicates(subset=["match_id", "end_id"])
    .reset_index(drop=True)
)
```

```{python}
# no end should have multiple different team_id1/team_id2 pairs
dup_check = df.groupby(["match_id", "end_id"])[["team_id1", "team_id2"]].nunique()
bad_ends = dup_check[(dup_check["team_id1"] > 1) | (dup_check["team_id2"] > 1)]
if len(bad_ends):
    raise ValueError(f"Found ends with inconsistent team_id1/team_id2:\n{bad_ends.head()}")
```

passes quality control.

```{python}
# ends already has: match_id, end_id, team_id1, team_id2

team_end_a = ends.copy()
team_end_a["team_id"] = team_end_a["team_id1"]
team_end_a["opp_team_id"] = team_end_a["team_id2"]

team_end_b = ends.copy()
team_end_b["team_id"] = team_end_b["team_id2"]
team_end_b["opp_team_id"] = team_end_b["team_id1"]

team_end = pd.concat([team_end_a, team_end_b], ignore_index=True)[
    ["match_id", "end_id", "team_id", "opp_team_id", "team_id1", "team_id2"]
]

# Checks
assert len(team_end) == 2 * len(ends)
assert (team_end["team_id"] != team_end["opp_team_id"]).all()

team_end.head()
```

this new dataframe, team_end, just serves for future assignments.

## Data

A new dataframe must be constructed which creates exactly two rows per
match_id and end_id; one for team_id1 and one for team_id2.
Each observational unit (so for each time) is intended to quantify the
decisions made by each team during the end without using every single
shot-row (too granular, useless).

The outcome is to see how much each team changed the sheet over the end,
not what did the shooter do on one shot (stone-level).

We will do this by taking the set of unique ends (match_id, end_id) and
cross-joining with both team_id_i. We keep these keys and add
opp_team_id as a new key. 

## Attach End-context to both team-end rows.

